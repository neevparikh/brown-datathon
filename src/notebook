{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Cell Segmentation Challenge Example\n",
    "This code is a basic example of the neuron segmentation challenge. The goal is to identify the locations of neurons within electron microscope images of brain tissue. We will train on fruit fly volumes and generalize to mouse volumes.\n",
    "\n",
    "We will load the data, and then define a UNet, which is an image segmantation model. We will do this using Keras (https://keras.io/), which is a high-level Python library for deep learning. We will then use Keras to train and   \n",
    "\n",
    "References:\n",
    "- Paper that defined the UNet: https://arxiv.org/pdf/1505.04597.pdf\n",
    "- Recent paper on neuron segmentation from the Serre lab at Brown: https://arxiv.org/pdf/1811.11356.pdf.\n",
    "  Note that in this paper, the network uses 3D convolution, while we use 2D here. Feel free to experiment with both!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np\n",
    "from numpy import load\n",
    "\n",
    "# Load fruit fly data for training.\n",
    "data = load('fruit_fly_volumes.npz')\n",
    "train_volume = np.expand_dims(data['volume'], axis=-1)\n",
    "train_label = np.expand_dims(data['label'], axis=-1)\n",
    "\n",
    "# Load mouse data for evaluation.\n",
    "data = load('mouse_volumes.npz')\n",
    "test_volume = np.expand_dims(data['volume'], axis=-1)\n",
    "test_label = np.expand_dims(data['label'], axis=-1)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "from keras.layers import Input, Conv2D, MaxPooling2D, Dropout, UpSampling2D, concatenate\n",
    "from keras.models import Model\n",
    "from keras.optimizers import Adam\n",
    "\n",
    "# Define a U-Net using Keras.\n",
    "# Code modified from https://github.com/zhixuhao/unet\n",
    "def small_unet(input_size=(1248, 1248, 1)):\n",
    "    inputs = Input(input_size)\n",
    "    conv1 = Conv2D(16, 3, activation='relu', padding='same', kernel_initializer='he_normal')(inputs)\n",
    "    conv1 = Conv2D(16, 3, activation='relu', padding='same', kernel_initializer='he_normal')(conv1)\n",
    "    pool1 = MaxPooling2D(pool_size=(2, 2))(conv1)\n",
    "\n",
    "    conv2 = Conv2D(32, 3, activation='relu', padding='same', kernel_initializer='he_normal')(pool1)\n",
    "    conv2 = Conv2D(32, 3, activation='relu', padding='same', kernel_initializer='he_normal')(conv2)\n",
    "    drop2 = Dropout(0.5)(conv2)\n",
    "    pool2 = MaxPooling2D(pool_size=(2, 2))(drop2)\n",
    "\n",
    "    conv3 = Conv2D(64, 3, activation='relu', padding='same', kernel_initializer='he_normal')(pool2)\n",
    "    conv3 = Conv2D(64, 3, activation='relu', padding='same', kernel_initializer='he_normal')(conv3)\n",
    "    drop3 = Dropout(0.5)(conv3)\n",
    "\n",
    "    up4 = Conv2D(32, 2, activation='relu', padding='same', kernel_initializer='he_normal')(\n",
    "        UpSampling2D(size=(2, 2))(drop3))\n",
    "    merge4 = concatenate([drop2, up4], axis=3)\n",
    "    conv4 = Conv2D(32, 3, activation='relu', padding='same', kernel_initializer='he_normal')(merge4)\n",
    "    conv4 = Conv2D(32, 3, activation='relu', padding='same', kernel_initializer='he_normal')(conv4)\n",
    "\n",
    "    up5 = Conv2D(16, 2, activation='relu', padding='same', kernel_initializer='he_normal')(\n",
    "        UpSampling2D(size=(2, 2))(conv4))\n",
    "    merge5 = concatenate([conv1, up5], axis=3)\n",
    "    conv5 = Conv2D(16, 3, activation='relu', padding='same', kernel_initializer='he_normal')(merge5)\n",
    "    conv5 = Conv2D(16, 3, activation='relu', padding='same', kernel_initializer='he_normal')(conv5)\n",
    "    conv5 = Conv2D(2, 3, activation='relu', padding='same', kernel_initializer='he_normal')(conv5)\n",
    "    conv6 = Conv2D(1, 1, activation='sigmoid')(conv5)\n",
    "\n",
    "    model = Model(input=inputs, output=conv6)\n",
    "\n",
    "    model.compile(optimizer=Adam(lr=1e-4), loss='mean_squared_error', metrics=['accuracy'])\n",
    "\n",
    "    return model"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# Train and evaluate.\n",
    "model = small_unet()\n",
    "model.fit(x=train_volume, y=train_label, batch_size=20, epochs=1)\n",
    "print(model.evaluate(x=test_volume, y=test_label))"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
